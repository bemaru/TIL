// 목적 :  
// 알지만 정리되지 않은 개념, 알고있는 개념이지만 키워드가 혼동되는 것들 그리고 모르는부분 등에 대해 보충
// 키워드에 대한 깔끔한 설명이나 기억하고 싶은 포인트에 대해 메모
// 읽기 진도 파악

1부 전문가를 향한 C++ 첫걸음
- initializer_list
 -POD
 
 1.2.2
- stack frame
> 스택 프레임은 각각의 함수마다 독립적인 메모리 공간을 제공한다는 점에서 굉장히 유용하다.
> 힙이란 현재 함수 또는 스택 프레임과 오나전히 독립적인 메모리 공간이다.

> 역참조란 포인터가 힙에 있는 실젯값을 가리키는 화살표를 따라간다는 뜻이다.  

// new, delete, new[], delete[] 사용하라고 하지만 RAII가 더 나은 선택지가 되는 경우가 많음  
널 포인터 상수 nullptr
- 스마트 포인터
> 기존 C 스타일의 포인터 대신 스마트 포인터를 사용하면 메모리와 관련하여 흔히 발생하는 문제를 방지 할 수 있다.  
> 스마트 포인터로 지정한 객체가 스코프를 벗어나면 메모리가 자동으로 해제된다.  
> unique_ptr는 포인터로 가리키는 대상이 스코프를 벗어나거나 삭제될 때 할당된 메모리나 리소스도 자동으로 삭제된다는 점을 제외하면 일반 포인터와 같다.  
> 그러나 unique_ptr가 가리키는 객체를 일반 포인터로는 가리킬 수 없다.  
> unique_ptr는 return 문이 실행되거나 익셉션이 발생하더라도 항상 할당된 메모리나 리소스를 해제할 수 있다는 장점이 있다.  
> 그래서 함수에 return 문을 여러 개 작성하더라도 각각에 대해 리소스를 해제하는 코드를 작성할 필요가 없기 때문에 함수를 간결하게 작성할 수 있다.  
```c++
auto anEmployee = make_unique<Employee>(); //c++14
```
```c++
unique_ptr<Employee> anEmployee(new Employee); // c++14 이전
```
```c++
auto emplyoess = make_unique<Employee[]>(10); // c style array
cout << " Salary: " << employees[0].salary << endl;
```
> 기존에 사용하던 일반 포인터는 소유권과 관련이 없는 경우에만 사용한다. 그 외에는 unique_ptr를 기본으로 사용하고
> 소유권을 공유할 필요가 있다면 shared_ptr를 사용한다. auto_ptr는 신경 쓸 필요 없다.
> C++11/14 버전부터 deprecated됐고, C++17부터 완전히 remove됐다.

1.2.3 const의 다양한 용도
//다양하게 사용되며 미묘한 차이가 있어 면접 때 물어보기 딱 좋다.
> C에선 흔히 #define으로 상수를 선언하지만, C++에서는 상수를 #define 대신 const로 정의하는 것이 바람직하다.

> #define은 전처리기가 처리하고, const는 컴파일러가 처리한다. 즉, define 문은 코드를 메타 수준으로 처리해서 언어의
> 구문과 의미에 대해 신경 쓰지 않고 워드프로세서의 찾아 바꾸기처럼 단순히 텍스트 매칭 작업을 수행한다. 
> 반면, const는 메타 수준이 아닌 C++ 코드 문맥 안에서 컴파일러가 평가한다. 그래서 const로 정의할 대상에 타입이나 스코프를 적용할 수 있다는 장점이 있다.

1.2.4 레퍼런스
> 코드에서 다루는 방법은 일반 변수와 같지만 내부적으로 원본 변수에 대한 포인터를 취급한다.  

> 레퍼런스 매개변수인 함수에 인자로 리터럴을 지정하면 컴파일 에러가 발생한다. 이때는 const레퍼런스나 rvalue(우측값)레퍼런스로 전달한다.  
> 복제가 부담스러운 큰 구조체나 클래스는 non-const 레퍼런스로 받아 작업 수행 후 그 결과를 리턴하지 않고 내부에서 곧바로 수정하는 방식을 많이 사용한다.  
> 하지만 C++11부터 추가된 move semantics 덕분에 복제하지 않고도 구조체나 클래스를 직접 리턴할 수 있다.  
> const 레퍼런스로 전달하면 복제되지도 않고 원본 변수가 변경되지 않는 장점을 모두 취할 수 있다.
> 

1.2.5 익셉션
> 익셉션이란 예상하지 못한 상황을 표현하는 클래스/객체

1.2.6 타입 추론
타입추론(type inreference)이란 표현식의 타입을 컴파일러가 스스로 알아내는 기능이다.
타입 추론과 관련된 키워드로 auto와 decltype이 있다.
- 함수 리턴 타입 추론
- 구조적 바인딩
- 표현식 타입 추론
- non-type 템플릿 매개변수의 타입 추론
- decltype(auto)
- 함수에 대한 또 다른 문법
- 제네릭 람다 표현식

```c++
auto f1 = foo();
```
auto를 지정하면 레퍼런스와 const 한정자가 사라지기 때문에 f1은 string 타입이 된다. 따라서 값이 **복제돼버린다.**
```c++
const auto& f2 = foo(); // 복제방지
```
