// 목적 :  
// 알지만 정리되지 않은 개념, 알고있는 개념이지만 키워드가 혼동되는 것들 그리고 모르는부분 등에 대해 보충
// 키워드에 대한 깔끔한 설명이나 기억하고 싶은 포인트에 대해 메모
// 읽기 진도 파악

1부 전문가를 향한 C++ 첫걸음
- initializer_list
 -POD
 
 1.2.2
- stack frame
> 스택 프레임은 각각의 함수마다 독립적인 메모리 공간을 제공한다는 점에서 굉장히 유용하다.
> 힙이란 현재 함수 또는 스택 프레임과 오나전히 독립적인 메모리 공간이다.

> 역참조란 포인터가 힙에 있는 실젯값을 가리키는 화살표를 따라간다는 뜻이다.  

// new, delete, new[], delete[] 사용하라고 하지만 RAII가 더 나은 선택지가 되는 경우가 많음  
널 포인터 상수 nullptr
- 스마트 포인터
> 기존 C 스타일의 포인터 대신 스마트 포인터를 사용하면 메모리와 관련하여 흔히 발생하는 문제를 방지 할 수 있다.  
> 스마트 포인터로 지정한 객체가 스코프를 벗어나면 메모리가 자동으로 해제된다.  
> unique_ptr는 포인터로 가리키는 대상이 스코프를 벗어나거나 삭제될 때 할당된 메모리나 리소스도 자동으로 삭제된다는 점을 제외하면 일반 포인터와 같다.  
> 그러나 unique_ptr가 가리키는 객체를 일반 포인터로는 가리킬 수 없다.  
> unique_ptr는 return 문이 실행되거나 익셉션이 발생하더라도 항상 할당된 메모리나 리소스를 해제할 수 있다는 장점이 있다.  
> 그래서 함수에 return 문을 여러 개 작성하더라도 각각에 대해 리소스를 해제하는 코드를 작성할 필요가 없기 때문에 함수를 간결하게 작성할 수 있다.  
```c++
auto anEmployee = make_unique<Employee>(); //c++14
```
```c++
unique_ptr<Employee> anEmployee(new Employee); // c++14 이전
```
```c++
auto emplyoess = make_unique<Employee[]>(10); // c style array
cout << " Salary: " << employees[0].salary << endl;
```
> 기존에 사용하던 일반 포인터는 소유권과 관련이 없는 경우에만 사용한다. 그 외에는 unique_ptr를 기본으로 사용하고
> 소유권을 공유할 필요가 있다면 shared_ptr를 사용한다. auto_ptr는 신경 쓸 필요 없다.
> C++11/14 버전부터 deprecated됐고, C++17부터 완전히 remove됐다.

1.2.3 const의 다양한 용도
//다양하게 사용되며 미묘한 차이가 있어 면접 때 물어보기 딱 좋다.
> C에선 흔히 #define으로 상수를 선언하지만, C++에서는 상수를 #define 대신 const로 정의하는 것이 바람직하다.

> #define은 전처리기가 처리하고, const는 컴파일러가 처리한다. 즉, define 문은 코드를 메타 수준으로 처리해서 언어의
> 구문과 의미에 대해 신경 쓰지 않고 워드프로세서의 찾아 바꾸기처럼 단순히 텍스트 매칭 작업을 수행한다. 
> 반면, const는 메타 수준이 아닌 C++ 코드 문맥 안에서 컴파일러가 평가한다. 그래서 const로 정의할 대상에 타입이나 스코프를 적용할 수 있다는 장점이 있다.

1.2.4 레퍼런스
> 코드에서 다루는 방법은 일반 변수와 같지만 내부적으로 원본 변수에 대한 포인터를 취급한다.  

> 레퍼런스 매개변수인 함수에 인자로 리터럴을 지정하면 컴파일 에러가 발생한다. 이때는 const레퍼런스나 rvalue(우측값)레퍼런스로 전달한다.  
> 복제가 부담스러운 큰 구조체나 클래스는 non-const 레퍼런스로 받아 작업 수행 후 그 결과를 리턴하지 않고 내부에서 곧바로 수정하는 방식을 많이 사용한다.  
> 하지만 C++11부터 추가된 move semantics 덕분에 복제하지 않고도 구조체나 클래스를 직접 리턴할 수 있다.  
> const 레퍼런스로 전달하면 복제되지도 않고 원본 변수가 변경되지 않는 장점을 모두 취할 수 있다.
> 

1.2.5 익셉션
> 익셉션이란 예상하지 못한 상황을 표현하는 클래스/객체

1.2.6 타입 추론
타입추론(type inreference)이란 표현식의 타입을 컴파일러가 스스로 알아내는 기능이다.
타입 추론과 관련된 키워드로 auto와 decltype이 있다.
- 함수 리턴 타입 추론
- 구조적 바인딩
- 표현식 타입 추론
- non-type 템플릿 매개변수의 타입 추론
- decltype(auto)
- 함수에 대한 또 다른 문법
- 제네릭 람다 표현식

```c++
auto f1 = foo();
```
auto를 지정하면 레퍼런스와 const 한정자가 사라지기 때문에 f1은 string 타입이 된다. 따라서 값이 **복제돼버린다.**
```c++
const auto& f2 = foo(); // 복제방지
```

decltype 키워드는 인수로 지정한 표현식의 타입을 알아낸다.
```c++
int x = 123;
decltype(y) y = 456;
```
decltyped은 레퍼런스나 const 지정자를 삭제하지 않는다는 점에서 auto와 다르다.
```c++
decltype(foo()) f2 = foo();
```

클래스란 객체의 특성을 정의한 것이다.  
데이터 멤버와 메서드 마다 public, protected, private 등으로 접근 수준을 지정한다.  

cosnt-정확성 원칙(**const-correctness principle**)에 따르면 객체의 데이터 멤버 값을 변경하지 않는 함수는  
항상  const로 지정하는 것이 좋다. 이렇게 지정한 멤버 함수를 '인스펙터(inspector), 접근자(accessor) 또는 게터(getter)'라 부르며,  
non-const 멤버 함수를 '뮤테이터(mutator, 변경자)'라 부른다.  

생서자와 형태는 같지만 앞에 **틸테(~)**를 붙인 메서드를 소멸자라 부른다.  

생성자로 데이터 멤버를 초기화하는 방법은 두 가지다. 권장하는 방법은 생성자 이니셜라이저(**ctor 이니셜라이저**)를 사용하는 것으로,  
생성자 이름 뒤에 콜론(:)을 붙여서 표현한다.  

ctor에서 데이터 멤버 초기화만 하고 다른일은 하지 않는다면 굳이 ctor를 따로 정의할 필요는 없다.  
클래스를 정의하는 코드 안에서 곧바로 데이터 멤버를 초기화해도 되기 때문이다.  

dtor도 실제로 하는일이 없다면 굳이 작성할 필요는 없다.  

1.4 유니폼 초기화
C++11 이전에는 타입 초기화 방식이 일정하지 않았다.  
```c++
CircleStruct myCircle1 = {10, 10, 2, 5};
CircleClass myCircle2(10, 10, 2, 5);
```
C++ 11부터 타입 초기화 {...}문법을 사용하는 유니폼 초기화(uniform initialization)를 따르도록 통일됐다.
```
CircleClass mCircle4 = {10, 10, 2, 5};
CircleClass mCircle6{10, 10, 2, 5};
int c = {3};
int d{3};
int e{};
```
유니폼 초기화를 사용하면 축소 변환(narrowing)을 방지할 수 있다. 
```c++
void func(int i) { /* ... */ }

int main()
{
 int x = {3.14}; // 축소로 인한 에러
 func({3.14}); // 축소로 인한 에러
}
```

```c++
int* pArray = new int[4]{0, 1, 2, 3};
```

1.4.1 직접 리스트 초기화와 복제 리스트 초기화  
복제 리스트 초기화(copy list initialization) : T obj = {arg1, arg2, ...};  
직접 리스트 초기화(direct list initialization) : T obj {arg1, arg2, ...};  

C++17부터는 auto 타입 추론 기능과 관련하여 복제 리스트 초기화와 직접 리스트 초기화가 크게 달라졌다.  
C++17 이전(C++11/14)에는 복제 리스트 초기화와 직접 리스트 초기화 모두 initializer_list<>로 처리했다.  
```c++
// 복제 리스트 초기화
auto b = {11};  // initializer_list<int>
auto b = {11, 22};  // initializer_list<int>

auto c {11};   // initializer_list<int>
auto d {11, 22};  // initializer_list<int>
```

C++17부터는 auto는 직접 리스트 초기화에 대해 값 하나만 추론한다.
```c++
// 복제 리스트 초기화
auto b = {11};  // initializer_list<int>
auto b = {11, 22};  // initializer_list<int>

auto c {11};   // int
auto d {11, 22};  // 원소가 너무 많다는 에러가 발생한다.
```
복제 리스트 초기화에서 중괄호 안에 나온 원소는 반드시 타입이 모두 같아야 한다.
```c++
auto b = {11, 22.33}; // 컴파일 에러
```
// 이 책에서는 상수의 이름을 정할 때 상수를 의미하는 독일어 Konstant의 첫 글자인 k를 상수 앞에 붙이는 관례를 따른다
